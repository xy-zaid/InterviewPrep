DSA 

2 Pointer technique

https://www.geeksforgeeks.org/two-pointers-technique

https://algodaily.com/lessons/using-the-two-pointer-technique/java

-------------------------------------------------------------------------------


Sorting 

# if you increasing or decreasing in powers of 2 , it will be log N to base 2
    64 (N) -> 32 (N/2) -> 16 (N/4) -> 8 (N/8) -> 4 (N/16) -> 2 (N/32) -> 1 (N/64)
    64 is 2 ^6, log 8 base 2 gives 3, meaning how many times base should be multiplied with itself so that we get 8

# If algo gives different Time Complexity for differnt inputs then it is input dependant(Bubble)
    eg- best case -O(n) , worst case 0(n^2)

# If algo does not give different Time Complexity for differnt inputs then it is input independent(Selection, Merge )
    eg- best case -O(n^2) , worst case 0(n^2)

 ------

    Selection Soritng - 

        # Select a minimum value and swap with index whose value is less than the mnimumm
        # Left side is sorted with each iteration. 
        # elements are scanned and put to theor correct position at once, their posi will not change again

        # Unstable sort because if duplicate values are there in the array to be sorted, then the index of the
          first duplicate value will increase/change to more than the second duplicate value

          If first duplicate value is at 3rd postion and second dup value is at 5th, then S.D.V will stay at 5th but F.D.V will be move to 6th index.

        # First iteration is to access each element of the array....and 
            for each of this iteration one more iteration will run for comparing the least value so that it can be swapped. therefore 0(n^2) for all case scenario

    --------------------------------------------
    
    Bubble Soritng - 

        # Pair(Bubble) comparison  and swap
        # will push the largest value to right hand side by PAIR comparison and with each iteration the unsorted array region will decrease.
        # We are exchanging adjacent positions here based on PAIR comparison and elements can again change their position.

        # Stable sort because if duplicate values are there in the array, then the index of the
          first duplicate value will remain same. Maintains the order.

          If first duplicate value is at 3rd postion and second dup value is at 5th, then S.D.V will stay at 5th and F.D.V will stay at 3rd index.

        # First iteration is to access each element of the array except the last index....and 
            for each of this iteration one more iteration will run for comparing the PAIR so that it can be swapped. therefore 0(n^2) fro worst case scenario

        # But we can optimize or improve this algo by adding a swap flag after first iteration, after comparing PAIRS if swap flag is still false , it means that the array is sorted so we do not need to sort or iterate any further. this is best scenario where timecomplexity will be 0(n)

    --------------------------------------------------

    Merge Sorting -

        # Follows Post Order tree traversal only conceptually , In a post-order tree traversal, you typically visit the left subtree, then the right subtree, and finally the root node.This process doesn't involve traversing a tree data structure; instead, it operates directly on arrays.

        #Based on 2 different algos 
            (a) Binary partition using recursion
                    The array is recursively divided into into smaller subarrays untill the subarrays are of size 1 with base condition l<h
                    we will not create a sub array, we will just change the position for low , mid and high
                    mid= (l+h)/2
            (b) Merge two sorted List
                take two arrays left array and right using Arrays.copyOfRange(arr,InclusiveFrom,exclusiveTo)
                and compare the elements of the two array and add them accordingly into the original array.

        # Recursion tree
                            N 
                N/2                 N/2
            N/4      N/4    N/4             N/4
        N/N N/N  N/N  N/N  N/N N/N    N/N   N/N     **[UNTILL SIZE IS 1]

        at each level we are comparing and merging the array , it is of order 0(n) at each level.
        * adding N/2 + N/2 , ultimately we get N items to be compared, and in the same way for each level ultimately we are comparing N 
          items only, therefore it is of 0(n) at each level.

        # Height of this tree -

        N->N/2->N/4->...1 therefore TC is log(N)

        # N log(N) is the TC. 0(n) for merge and logn for recursion.
        # we use Merge sort in linked list because it does not requires Random access and for array we use Quick Sort

    ----------------------------------------------------------

    Quick Sorting - 

        #First Select A pivot , either the first element of array, last element , median or random element.

        # Partition the pivot element using 2 pointers and store at an index and this index will be its correct postion according to the given order. We will not have to touch this element ever, so that all elements that are smaller will be at the left side and all larger elements will be at right side. 
        (these first 2 steps are to be taken care by a different method and while loop and return the pivot index)

        # inside Partition method we check using 2 pointers if there is any value which is greater and smaller from both polar ends and swap them untill 1st pointer crosses the second pointer which means that all values to left of that index is small, so we swap that index with the pivot value and return the index.

        ----------------------------------------------------------------------------

        # recursively call the left and right side of the pivot element and again partition it so that left side will be smaller and right side will be larger.


        # merge sort and quick sort both have same time complexity but Space complexity of MS is 0(n) and of QS is 0(1)
        # best and avg = 0(nlogN) , worst case = 0(N^2)

======================================================================================================

Arrays

    Easy ->
     
     # Largest Element in an Array
        
       * Either use Arrays.stream or iterate over the array "max = Math.max(max, arr[i])"

     ------------------------

     # Second Largest Element in an Array 

        * iterate over the array, any number that is closest to the largest number is the number that was there before the new larger value is assigned to the max variable. therefore before adding the new larger value take the value that is to be removed and store in second largest.
        for example we are iterating an array [1234] around last iteration largest varibale will store 3 inside but when the condition -> arr[i] > large is satisfied , 4 will be added to it. therefore before "large = arr[i]" do this -> " second_large = large "
        
        second condition is when we have such an array -> 23915 , In this case we can see that 5 will come at the last iteration , so if we only use the first condition then we will not satisfy it and we will not get the correct second_large value.
        "arr[i] > second_large && arr[i] != large" this should be your second condition where it checks if the current value is gt second_large if true then check if thet value is large value or not, if satisfied then second_large = arr[i]. 0(n).

    --------------------------

     # Check if the array is sorted 

        * array is sorted in ascending order if current element is smaller than the preceding element.
        this will be our base condition , if this is not satisfied return false.
        if(curr>precedingElement)  this was we dont have to iterate over n times. the moent we knoe the array is unsorted, we break out and optimize our code.

    ------------------------------

     # Remove duplicates from Sorted array
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     (Given an integer array sorted in non-decreasing order, remove the duplicates in place such that each unique element appears only once. The relative order of the elements should be kept the same. 
     If there are k elements after removing the duplicates, then the first k elements of the array should hold the final result. It does not matter what you leave beyond the first k elements.
     Return k after placing the final result in the first k slots of the array.)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        * Brute force approach would be to use set data structure, so that no duplicates will be saved and we will get our noDuplicateArray . this requires two loops. so 0(n) +0(n) and space will be 0(n)

        * we can also do this in 0(n) and 0(1) space complexity by using 2 Pointer technique. The slow and fast 2 pointer approach will work fine here, 
        1st pointer will be duplicatePointer which will continuously iterate over the array.
        2nd pointer will be nonDuplicatePointer.

        we will compare the two pointers -> " arr[duplicatePointer] != arr[nonDuplicatePointer] "

        if condition is not true, duplicatePointer will increment through loop thereby signifying that the preceding vlaues are duplicate

        * if condition is false it means we are at an index where we have found a non duplicate value. so we will swap this element.
        but nonDuplicatePointer is still at 0th index, where should we store the latest non duplicate value ?
        if we remember the questionhas clearly mentioned that -> 'The relative order of the elements should be kept the same.'
        therefore for eg 111122 in this array the realtive order is that after 1 2 is coming. so we will have to store this nonDuplicate value that is *2* at the postion after 1 -> 121122.
        so before storing the latest non duplicate value at nonDuplicatePointer. we should increment its index to 1st
        " nonDuplicatePointer++ "

        now the nonDuplicatePointer is pointing at the correct index, this way the relative order is also maintained. 
        " arr[nonDuplicatePointer] = arr[duplicatePointer] "

    ----------------------------------------

    # Left rotate an array by D places

        * 



    